"""
Script de An√°lise Comparativa entre YOLOv8 e MediaPipe

Este script executa testes de performance e gera relat√≥rios comparativos
entre as duas abordagens de detec√ß√£o de Rock Paper Scissors.

Autor: Projeto de Vis√£o Computacional
Data: 2025
"""

import cv2
import time
import numpy as np
from mediapipe_realtime import RockPaperScissorsDetector
from pathlib import Path
import json
import matplotlib.pyplot as plt
import seaborn as sns


def test_mediapipe_performance(video_source=0, duration=30):
    """
    Testa a performance do MediaPipe por um per√≠odo espec√≠fico.
    
    Args:
        video_source: Fonte de v√≠deo (webcam)
        duration: Dura√ß√£o do teste em segundos
        
    Returns:
        Dicion√°rio com estat√≠sticas de performance
    """
    print("\nüîµ Testando MediaPipe...")
    print(f"Dura√ß√£o do teste: {duration}s")
    
    detector = RockPaperScissorsDetector()
    cap = cv2.VideoCapture(video_source)
    
    if not cap.isOpened():
        print("‚ùå Erro ao abrir webcam")
        return None
    
    # Estat√≠sticas
    frame_count = 0
    detection_count = 0
    inference_times = []
    fps_values = []
    gesture_detections = []
    
    start_time = time.time()
    prev_time = start_time
    
    print("üé• Capturando frames...")
    
    while True:
        current_time = time.time()
        elapsed = current_time - start_time
        
        if elapsed >= duration:
            break
        
        success, frame = cap.read()
        if not success:
            break
        
        frame = cv2.flip(frame, 1)
        
        # Medir tempo de infer√™ncia
        infer_start = time.time()
        processed_frame, detections = detector.process_frame(frame)
        infer_time = (time.time() - infer_start) * 1000
        
        # Coletar estat√≠sticas
        frame_count += 1
        inference_times.append(infer_time)
        
        if detections:
            detection_count += len(detections)
            for det in detections:
                gesture_detections.append(det['gesture'])
        
        # Calcular FPS
        fps = 1 / (current_time - prev_time) if prev_time > 0 else 0
        fps_values.append(fps)
        prev_time = current_time
        
        # Mostrar progresso
        if frame_count % 30 == 0:
            print(f"‚è±Ô∏è  {elapsed:.1f}s / {duration}s - {frame_count} frames")
    
    cap.release()
    detector.release()
    
    total_time = time.time() - start_time
    
    # Calcular estat√≠sticas
    stats = {
        'method': 'MediaPipe',
        'duration': total_time,
        'frame_count': frame_count,
        'detection_count': detection_count,
        'avg_fps': np.mean(fps_values),
        'min_fps': np.min(fps_values),
        'max_fps': np.max(fps_values),
        'avg_inference_time': np.mean(inference_times),
        'min_inference_time': np.min(inference_times),
        'max_inference_time': np.max(inference_times),
        'std_inference_time': np.std(inference_times),
        'detection_rate': (detection_count / frame_count) * 100,
        'gesture_distribution': {
            'Rock': gesture_detections.count('Rock'),
            'Paper': gesture_detections.count('Paper'),
            'Scissors': gesture_detections.count('Scissors'),
        }
    }
    
    print("\n‚úÖ Teste MediaPipe conclu√≠do!")
    return stats


def test_yolov8_performance(model_path, video_source=0, duration=30):
    """
    Testa a performance do YOLOv8 por um per√≠odo espec√≠fico.
    
    Args:
        model_path: Caminho do modelo YOLOv8
        video_source: Fonte de v√≠deo
        duration: Dura√ß√£o do teste em segundos
        
    Returns:
        Dicion√°rio com estat√≠sticas de performance
    """
    print("\nüü¢ Testando YOLOv8...")
    print(f"Modelo: {model_path}")
    print(f"Dura√ß√£o do teste: {duration}s")
    
    # Verificar se modelo existe
    if not Path(model_path).exists():
        print(f"‚ùå Modelo n√£o encontrado: {model_path}")
        return None
    
    try:
        from ultralytics import YOLO
        model = YOLO(model_path)
    except Exception as e:
        print(f"‚ùå Erro ao carregar modelo: {e}")
        return None
    
    cap = cv2.VideoCapture(video_source)
    
    if not cap.isOpened():
        print("‚ùå Erro ao abrir webcam")
        return None
    
    # Estat√≠sticas
    frame_count = 0
    detection_count = 0
    inference_times = []
    fps_values = []
    class_detections = []
    confidence_values = []
    
    start_time = time.time()
    prev_time = start_time
    
    print("üé• Capturando frames...")
    
    while True:
        current_time = time.time()
        elapsed = current_time - start_time
        
        if elapsed >= duration:
            break
        
        success, frame = cap.read()
        if not success:
            break
        
        frame = cv2.flip(frame, 1)
        
        # Medir tempo de infer√™ncia
        infer_start = time.time()
        results = model.predict(frame, conf=0.25, verbose=False)[0]
        infer_time = (time.time() - infer_start) * 1000
        
        # Coletar estat√≠sticas
        frame_count += 1
        inference_times.append(infer_time)
        
        if results.boxes is not None and len(results.boxes) > 0:
            detection_count += len(results.boxes)
            for box in results.boxes:
                class_id = int(box.cls[0])
                class_name = results.names[class_id]
                confidence = float(box.conf[0])
                class_detections.append(class_name)
                confidence_values.append(confidence)
        
        # Calcular FPS
        fps = 1 / (current_time - prev_time) if prev_time > 0 else 0
        fps_values.append(fps)
        prev_time = current_time
        
        # Mostrar progresso
        if frame_count % 30 == 0:
            print(f"‚è±Ô∏è  {elapsed:.1f}s / {duration}s - {frame_count} frames")
    
    cap.release()
    
    total_time = time.time() - start_time
    
    # Calcular estat√≠sticas
    stats = {
        'method': 'YOLOv8',
        'duration': total_time,
        'frame_count': frame_count,
        'detection_count': detection_count,
        'avg_fps': np.mean(fps_values),
        'min_fps': np.min(fps_values),
        'max_fps': np.max(fps_values),
        'avg_inference_time': np.mean(inference_times),
        'min_inference_time': np.min(inference_times),
        'max_inference_time': np.max(inference_times),
        'std_inference_time': np.std(inference_times),
        'detection_rate': (detection_count / frame_count) * 100,
        'avg_confidence': np.mean(confidence_values) if confidence_values else 0,
        'class_distribution': {
            'Rock': class_detections.count('Rock'),
            'Paper': class_detections.count('Paper'),
            'Scissors': class_detections.count('Scissors'),
        }
    }
    
    print("\n‚úÖ Teste YOLOv8 conclu√≠do!")
    return stats


def generate_comparison_report(mediapipe_stats, yolov8_stats, output_dir='results'):
    """
    Gera relat√≥rio comparativo detalhado.
    """
    print("\nüìä Gerando relat√≥rio comparativo...")
    
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True)
    
    # Salvar estat√≠sticas em JSON
    report_data = {
        'mediapipe': mediapipe_stats,
        'yolov8': yolov8_stats,
        'timestamp': time.strftime('%Y-%m-%d %H:%M:%S')
    }
    
    json_path = output_path / 'comparative_analysis.json'
    with open(json_path, 'w', encoding='utf-8') as f:
        json.dump(report_data, f, indent=2, ensure_ascii=False)
    print(f"üíæ Dados salvos em: {json_path}")
    
    # Gerar gr√°ficos
    generate_comparison_charts(mediapipe_stats, yolov8_stats, output_path)
    
    # Gerar relat√≥rio texto
    generate_text_report(mediapipe_stats, yolov8_stats, output_path)
    
    print("‚úÖ Relat√≥rio completo gerado!")


def generate_comparison_charts(mp_stats, yolo_stats, output_dir):
    """Gera gr√°ficos comparativos."""
    
    sns.set_style("whitegrid")
    
    # Gr√°fico 1: FPS Comparison
    fig, axes = plt.subplots(2, 2, figsize=(15, 12))
    
    # FPS
    methods = ['MediaPipe', 'YOLOv8']
    fps_avg = [mp_stats['avg_fps'], yolo_stats['avg_fps']]
    
    axes[0, 0].bar(methods, fps_avg, color=['#FF6F00', '#00D4FF'])
    axes[0, 0].set_title('FPS M√©dio', fontsize=14, fontweight='bold')
    axes[0, 0].set_ylabel('FPS')
    axes[0, 0].grid(axis='y', alpha=0.3)
    
    # Tempo de Infer√™ncia
    inference_avg = [mp_stats['avg_inference_time'], yolo_stats['avg_inference_time']]
    
    axes[0, 1].bar(methods, inference_avg, color=['#FF6F00', '#00D4FF'])
    axes[0, 1].set_title('Tempo de Infer√™ncia M√©dio', fontsize=14, fontweight='bold')
    axes[0, 1].set_ylabel('Tempo (ms)')
    axes[0, 1].grid(axis='y', alpha=0.3)
    
    # Taxa de Detec√ß√£o
    detection_rate = [mp_stats['detection_rate'], yolo_stats['detection_rate']]
    
    axes[1, 0].bar(methods, detection_rate, color=['#FF6F00', '#00D4FF'])
    axes[1, 0].set_title('Taxa de Detec√ß√£o', fontsize=14, fontweight='bold')
    axes[1, 0].set_ylabel('% de Frames')
    axes[1, 0].grid(axis='y', alpha=0.3)
    
    # Detec√ß√µes Totais
    total_detections = [mp_stats['detection_count'], yolo_stats['detection_count']]
    
    axes[1, 1].bar(methods, total_detections, color=['#FF6F00', '#00D4FF'])
    axes[1, 1].set_title('Total de Detec√ß√µes', fontsize=14, fontweight='bold')
    axes[1, 1].set_ylabel('Quantidade')
    axes[1, 1].grid(axis='y', alpha=0.3)
    
    plt.tight_layout()
    chart_path = output_dir / 'comparative_charts.png'
    plt.savefig(chart_path, dpi=300, bbox_inches='tight')
    print(f"üìà Gr√°ficos salvos em: {chart_path}")
    plt.close()


def generate_text_report(mp_stats, yolo_stats, output_dir):
    """Gera relat√≥rio em texto."""
    
    report = f"""
{'='*80}
RELAT√ìRIO COMPARATIVO - YOLOV8 vs MEDIAPIPE
Rock Paper Scissors Detection
{'='*80}

Data/Hora: {time.strftime('%Y-%m-%d %H:%M:%S')}

{'='*80}
MEDIAPIPE
{'='*80}

Performance:
  ‚Ä¢ FPS M√©dio: {mp_stats['avg_fps']:.2f}
  ‚Ä¢ FPS M√≠n/M√°x: {mp_stats['min_fps']:.2f} / {mp_stats['max_fps']:.2f}
  ‚Ä¢ Infer√™ncia M√©dia: {mp_stats['avg_inference_time']:.2f}ms
  ‚Ä¢ Infer√™ncia M√≠n/M√°x: {mp_stats['min_inference_time']:.2f}ms / {mp_stats['max_inference_time']:.2f}ms
  ‚Ä¢ Desvio Padr√£o: {mp_stats['std_inference_time']:.2f}ms

Detec√ß√µes:
  ‚Ä¢ Total de Frames: {mp_stats['frame_count']}
  ‚Ä¢ Total de Detec√ß√µes: {mp_stats['detection_count']}
  ‚Ä¢ Taxa de Detec√ß√£o: {mp_stats['detection_rate']:.1f}%

Distribui√ß√£o de Gestos:
  ‚Ä¢ Rock: {mp_stats['gesture_distribution']['Rock']}
  ‚Ä¢ Paper: {mp_stats['gesture_distribution']['Paper']}
  ‚Ä¢ Scissors: {mp_stats['gesture_distribution']['Scissors']}

{'='*80}
YOLOV8
{'='*80}

Performance:
  ‚Ä¢ FPS M√©dio: {yolo_stats['avg_fps']:.2f}
  ‚Ä¢ FPS M√≠n/M√°x: {yolo_stats['min_fps']:.2f} / {yolo_stats['max_fps']:.2f}
  ‚Ä¢ Infer√™ncia M√©dia: {yolo_stats['avg_inference_time']:.2f}ms
  ‚Ä¢ Infer√™ncia M√≠n/M√°x: {yolo_stats['min_inference_time']:.2f}ms / {yolo_stats['max_inference_time']:.2f}ms
  ‚Ä¢ Desvio Padr√£o: {yolo_stats['std_inference_time']:.2f}ms
  ‚Ä¢ Confian√ßa M√©dia: {yolo_stats['avg_confidence']:.1%}

Detec√ß√µes:
  ‚Ä¢ Total de Frames: {yolo_stats['frame_count']}
  ‚Ä¢ Total de Detec√ß√µes: {yolo_stats['detection_count']}
  ‚Ä¢ Taxa de Detec√ß√£o: {yolo_stats['detection_rate']:.1f}%

Distribui√ß√£o de Classes:
  ‚Ä¢ Rock: {yolo_stats['class_distribution']['Rock']}
  ‚Ä¢ Paper: {yolo_stats['class_distribution']['Paper']}
  ‚Ä¢ Scissors: {yolo_stats['class_distribution']['Scissors']}

{'='*80}
COMPARA√á√ÉO
{'='*80}

FPS:
  ‚Ä¢ MediaPipe: {mp_stats['avg_fps']:.2f} FPS
  ‚Ä¢ YOLOv8: {yolo_stats['avg_fps']:.2f} FPS
  ‚Ä¢ Diferen√ßa: {((mp_stats['avg_fps'] - yolo_stats['avg_fps']) / yolo_stats['avg_fps'] * 100):+.1f}%
  ‚Ä¢ Vencedor: {'MediaPipe' if mp_stats['avg_fps'] > yolo_stats['avg_fps'] else 'YOLOv8'} üèÜ

Tempo de Infer√™ncia:
  ‚Ä¢ MediaPipe: {mp_stats['avg_inference_time']:.2f}ms
  ‚Ä¢ YOLOv8: {yolo_stats['avg_inference_time']:.2f}ms
  ‚Ä¢ Diferen√ßa: {((yolo_stats['avg_inference_time'] - mp_stats['avg_inference_time']) / mp_stats['avg_inference_time'] * 100):+.1f}%
  ‚Ä¢ Mais R√°pido: {'MediaPipe' if mp_stats['avg_inference_time'] < yolo_stats['avg_inference_time'] else 'YOLOv8'} üèÜ

Taxa de Detec√ß√£o:
  ‚Ä¢ MediaPipe: {mp_stats['detection_rate']:.1f}%
  ‚Ä¢ YOLOv8: {yolo_stats['detection_rate']:.1f}%
  ‚Ä¢ Diferen√ßa: {(mp_stats['detection_rate'] - yolo_stats['detection_rate']):+.1f}pp
  ‚Ä¢ Maior: {'MediaPipe' if mp_stats['detection_rate'] > yolo_stats['detection_rate'] else 'YOLOv8'} üèÜ

{'='*80}
CONCLUS√ïES
{'='*80}

Velocidade: MediaPipe √© geralmente mais r√°pido em CPU.
Precis√£o: YOLOv8 tende a ter maior precis√£o ap√≥s treinamento adequado.
Recursos: MediaPipe consome menos recursos computacionais.
Flexibilidade: YOLOv8 √© mais flex√≠vel para diferentes objetos.

Recomenda√ß√£o:
- Para produ√ß√£o com recursos limitados: MediaPipe
- Para m√°xima precis√£o com GPU: YOLOv8
- Para prototipagem r√°pida: MediaPipe

{'='*80}
"""
    
    report_path = output_dir / 'comparative_report.txt'
    with open(report_path, 'w', encoding='utf-8') as f:
        f.write(report)
    
    print(f"üìÑ Relat√≥rio salvo em: {report_path}")
    print(report)


def main():
    """Fun√ß√£o principal."""
    
    print("=" * 80)
    print("AN√ÅLISE COMPARATIVA: YOLOv8 vs MediaPipe")
    print("=" * 80)
    print("\nEste script ir√° testar ambas as abordagens e gerar relat√≥rios comparativos.")
    print("\n‚ö†Ô∏è  IMPORTANTE:")
    print("  - Certifique-se de ter uma webcam conectada")
    print("  - Para YOLOv8, o modelo treinado deve estar em 'models/best.pt'")
    print("  - Mantenha condi√ß√µes consistentes durante os testes")
    print("  - Mostre gestos variados para an√°lise completa")
    
    input("\nPressione ENTER para continuar...")
    
    # Configura√ß√µes
    test_duration = 30  # segundos
    yolo_model_path = 'models/best.pt'
    
    # Teste 1: MediaPipe
    mp_stats = test_mediapipe_performance(duration=test_duration)
    
    if mp_stats is None:
        print("‚ùå Teste do MediaPipe falhou!")
        return
    
    print("\n" + "=" * 80)
    input("Pressione ENTER para iniciar teste do YOLOv8...")
    
    # Teste 2: YOLOv8
    yolo_stats = test_yolov8_performance(yolo_model_path, duration=test_duration)
    
    if yolo_stats is None:
        print("‚ùå Teste do YOLOv8 falhou!")
        print("üí° Certifique-se de ter treinado o modelo primeiro.")
        return
    
    # Gerar relat√≥rio
    generate_comparison_report(mp_stats, yolo_stats)
    
    print("\n" + "=" * 80)
    print("‚úÖ An√°lise comparativa conclu√≠da com sucesso!")
    print("üìÅ Verifique a pasta 'results/' para os relat√≥rios gerados.")
    print("=" * 80)


if __name__ == "__main__":
    main()

